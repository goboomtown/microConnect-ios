//
//  ChatViewController.m
//  BoomtownMember
//
//  Created by Larry Borsato on 2015-10-27.
//  Copyright Â© 2015 BOOMTOWN. All rights reserved.
//

#import "ChatViewController.h"
//#import "AppDelegate.h"
//#import <SVProgressHUD/SVProgressHUD.h>
#import "UIImage+animatedGIF.h"
#import "AnimatedTextAttachment.h"
//#import "Settings.h"
#import <Photos/Photos.h>
#ifdef EMBED
#import "BoomtownChat.h"
#import "BTMessagesCollectionViewCell.h"
#import "BTMessage.h"
#else
#import <STPopup/STPopup.h>
#import <BoomtownChat/BoomtownChat.h>
#import <BoomtownChat/BTMessagesCollectionViewCell.h>
#import <BoomtownChat/BTMessage.h>
#endif

#define UIColorFromRGB(rgbValue) [UIColor colorWithRed:((float)((rgbValue & 0xFF0000) >> 16))/255.0 green:((float)((rgbValue & 0xFF00) >> 8))/255.0 blue:((float)(rgbValue & 0xFF))/255.0 alpha:1.0]

#define kColorLink   0x56c4c0
#define kTimeout     30

#define kAutocompleteRowHeight		44.0
#define kAutocompleteTableHeight	132.0
@interface ChatViewController ()
{
	CGFloat tableViewOriginY;
	CGFloat textViewConstraintY;
	CGRect  chatViewOriginalFrame;
	NSArray	*mentions;
}

@property (strong, nonatomic) IBOutlet UIView *chatView;
@property (strong, nonatomic)			NSMutableArray		*buddies;
@property (strong, nonatomic)			NSMutableArray		*messages;
@property (strong, nonatomic)			NSMutableArray		*chatMessages;
@property (strong, nonatomic)			NSMutableArray		*avatars;
@property (strong, nonatomic)			BoomtownChat 		*boomtownChat;
@property (weak, nonatomic) IBOutlet 	UITextField 		*messageField;
@property (strong, nonatomic)			NSMutableDictionary	*textViews;
@property (weak, nonatomic) IBOutlet 	NSLayoutConstraint *reasonForResponseVerticalConstraint;
@property (weak, nonatomic) IBOutlet 	NSLayoutConstraint *topSpaceConstraint;
@property 								NSInteger			textViewWidth;
@property (strong, nonatomic)			NSArray				*history;

@property (strong, nonatomic) 			NSTimer				*connectTimer;
@property (strong, nonatomic) 			NSTimer				*joinRoomTimer;

@property (strong, nonatomic)			UILabel				*header;
@property (strong, nonatomic)			UIRefreshControl 	*refreshControl;
@property (strong, nonatomic)			UIButton            *sendButton;

@property (strong, nonatomic) JSQMessagesBubbleImage *outgoingBubbleImageData;
@property (strong, nonatomic) JSQMessagesBubbleImage *incomingBubbleImageData;
@property (strong, nonatomic) JSQMessagesAvatarImage *jobsImage;

@property (strong, nonatomic) AutocompletionTableView	*autocompletionTableView;
@property (strong, nonatomic) NSArray					*mentionSuggestions;

@property 					  BOOL						showing;

@property (strong, nonatomic) NSString                  *payload;
@property (strong, nonatomic) NSString                  *textViewText;

@property                     BOOL  visible;

@end

@implementation ChatViewController

- (instancetype)init
{
	if (self = [super init]) {
//        self.contentSizeInPopup = CGSizeMake(300, 400);
//        self.landscapeContentSizeInPopup = CGSizeMake(400, 200);
	}
	return self;
}


- (instancetype)initWithSize:(CGSize)size landscapeSize:(CGSize)landscapeSize
{
	if (self = [super init]) {
//        self.contentSizeInPopup = size;
//        self.landscapeContentSizeInPopup = landscapeSize;
	}
	return self;
}


- (void)viewDidLoad {
    [super viewDidLoad];

	APP_DELEGATE.chatViewController = self;

	self.jid      = [BoomtownAPI sharedInstance].current_member.xmpp_jid;
	self.password = [BoomtownAPI sharedInstance].current_member.xmpp_password;
	self.host     = [BoomtownAPI sharedInstance].current_member.xmpp_host;
	self.port     = [BoomtownAPI sharedInstance].current_member.xmpp_port;

    if ( self.port == nil )
        self.port = @"5222";

	self.inRoom = NO;

//    [BoomtownChat sharedInstance].colorLinkAndButtonTint = [Settings sharedInstance].colorLinkAndButtonTint;
//    [BoomtownChat sharedInstance].userPermissions = [BoomtownAPI sharedInstance].current_member.perms;

    NSString *xmppResource = [BoomtownAPI sharedInstance].current_member.xmpp_resource;
	NSArray *tokens = [xmppResource componentsSeparatedByString:@";"];
	self.resource = tokens[0];

	tokens = [self.resource componentsSeparatedByString:@";"];
	self.participantId = tokens[0];

	self.nickname	  = self.resource; //[self getChatInfoType:@"alias" forJid:self.jid];

	self.senderId	       = self.resource!=nil ? self.resource : @"Unknown";
	self.senderDisplayName = self.senderId;

	self.buddies        = [[NSMutableArray alloc] init];
	self.messages       = [[NSMutableArray alloc] init];
    self.chatMessages   = [[NSMutableArray alloc] init];
	self.avatars        = [[NSMutableArray alloc] init];

	self.textViewWidth = self.view.frame.size.width;
	self.textViews = [[NSMutableDictionary alloc] init];

	chatViewOriginalFrame = self.chatView.frame;

	self.messageField.delegate = self;

	//	Disable image selection button for now in chat input toolbar
//	self.inputToolbar.contentView.leftBarButtonItem = nil;

//	self.inputToolbar.contentView.rightBarButtonItem = [JSQMessagesToolbarButtonFactory defaultSendButtonItem];
	self.sendButton = (UIButton *) self.inputToolbar.contentView.rightBarButtonItem;
	[self.sendButton setTitleColor:[[UIColor jsq_messageBubbleBlueColor] jsq_colorByDarkeningColorWithValue:0.3f] forState:UIControlStateHighlighted];

	JSQMessagesBubbleImageFactory *bubbleFactory = [[JSQMessagesBubbleImageFactory alloc] init];
	self.outgoingBubbleImageData = [bubbleFactory outgoingMessagesBubbleImageWithColor:[UIColor jsq_messageBubbleGreenColor]];
	self.incomingBubbleImageData = [bubbleFactory incomingMessagesBubbleImageWithColor:[UIColor jsq_messageBubbleLightGrayColor]];

	self.collectionView.collectionViewLayout.messageBubbleLeftRightMargin = 50;

    UIImage *avatar = [APP_DELEGATE getAvatar:nil]; // Retreive the default avatar
	self.jobsImage = [JSQMessagesAvatarImageFactory avatarImageWithImage:avatar diameter:kJSQMessagesCollectionViewAvatarSizeDefault];

	[BoomtownChat sharedInstance].delegate = self;

	self.refreshControl = [[UIRefreshControl alloc] init];
	self.refreshControl.attributedTitle = [[NSAttributedString alloc] initWithString:NSLocalizedString(@"Pull to Load Earlier Messages",nil)];
	[self.refreshControl addTarget:self action:@selector(refreshLists:) forControlEvents:UIControlEventValueChanged];
	[self.collectionView addSubview:self.refreshControl];

	self.autocompletionTableView = [[AutocompletionTableView alloc] initWithTextView:self.inputToolbar.contentView.textView
																	inViewController:self];
	self.autocompletionTableView.autoCompleteDelegate = self;
	self.autocompletionTableView.suggestionsDictionary = self.mentionSuggestions;
	self.autocompletionTableView.layer.borderColor = (__bridge CGColorRef _Nullable)([UIColor blackColor]);
	self.autocompletionTableView.layer.borderWidth = 2.0;
	self.autocompletionTableView.tableHeight = kAutocompleteTableHeight;
	self.autocompletionTableView.rowHeight	 = kAutocompleteRowHeight;
	[self.view addSubview:self.autocompletionTableView];
	self.inputToolbar.contentView.textView.delegate = self;

    //    [self.collectionView registerNib:@"BTMessagesCollectionViewCellIncoming.xib"
    //forCellWithReuseIdentifier:[JSQMessagesCollectionViewCellIncoming mediaCellReuseIdentifier]];
    //
    //    [self.collectionView registerNib:@"BTMessagesCollectionViewCellOutgoing.xib"
    //forCellWithReuseIdentifier:[JSQMessagesCollectionViewCellOutgoing mediaCellReuseIdentifier]];

    [self.collectionView registerNib:[UINib nibWithNibName:@"BTMessagesCollectionViewCellIncoming" bundle:nil]
          forCellWithReuseIdentifier:[JSQMessagesCollectionViewCellIncoming cellReuseIdentifier]];

    [self.collectionView registerNib:[UINib nibWithNibName:@"BTMessagesCollectionViewCellOutgoing" bundle:nil]
          forCellWithReuseIdentifier:[JSQMessagesCollectionViewCellOutgoing cellReuseIdentifier]];

    [self.collectionView registerNib:[UINib nibWithNibName:@"BTMessagesCollectionViewCellIncoming" bundle:nil]
          forCellWithReuseIdentifier:[JSQMessagesCollectionViewCellIncoming mediaCellReuseIdentifier]];

    [self.collectionView registerNib:[UINib nibWithNibName:@"BTMessagesCollectionViewCellOutgoing" bundle:nil]
          forCellWithReuseIdentifier:[JSQMessagesCollectionViewCellOutgoing mediaCellReuseIdentifier]];

    _visible = NO;
}


- (void)textDidChange:(id<UITextInput>)textInput
{
    NSLog(@"textDidChange");
}


//- (void) showProviderInfo
//{
//	if ( self.provider != nil )
//	{
//		CGRect frame = self.view.frame;
//		frame.size.height = 60;
//		self.logoDescriptionView = [[LogoDescriptionView alloc] initWithFrame:frame];
//		dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
//			self.logoDescriptionView.logo.image = [[[BoomtownAPI sharedInstance] logoWithAvatar:self.provider.avatar] roundImage];
//		});
//		[self.view addSubview:<#(nonnull UIView *)#>]
//	}
//}


- (void)stopRefresh
{
	[self.refreshControl endRefreshing];

}


- (void)refreshLists:(id)sender
{
	[[BoomtownChat sharedInstance] requestRoomHistory];
	[self performSelector:@selector(stopRefresh) withObject:nil afterDelay:1.0];
}


- (void)didReceiveMemoryWarning {
    [super didReceiveMemoryWarning];
    // Dispose of any resources that can be recreated.
}


- (void)viewWillAppear:(BOOL)animated
{
	[super viewWillAppear:animated];

	self.showing = YES;

    //  If we were previously connected let's reconnect
    if ( self.chatRecord ) {
        if ( ![[BoomtownChat sharedInstance] isConnected] ) {
            [self connectWithTimeout:[Settings sharedInstance].timeoutChatConnect];
        } else {
            if ( !self.inRoom )
                [self joinRoom];
        }
    }

	[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(applicationStateChanged:) name:kApplicationStateChangedNotification object:nil];

	[[NSNotificationCenter defaultCenter] addObserver:self.autocompletionTableView
											 selector:@selector(textViewDidChange:)
												 name:UITextViewTextDidChangeNotification
											   object:self.inputToolbar.contentView.textView];
}


- (void)viewDidAppear:(BOOL)animated
{
	[super viewDidAppear:animated];

	[[NSNotificationCenter defaultCenter] removeObserver:self.autocompletionTableView
													name:UITextViewTextDidChangeNotification
												  object:self.inputToolbar.contentView.textView];

}


- (void)viewWillDisappear:(BOOL)animated
{
	[super viewWillDisappear:animated];

	self.showing = NO;

    dispatch_async(dispatch_get_main_queue(), ^{
        [SVProgressHUD dismiss];
    });

	[[NSNotificationCenter defaultCenter] removeObserver:self name:kApplicationStateChangedNotification object:nil];
}


- (IBAction)backButtonPressed:(id)sender {
	[self dismissViewControllerAnimated:YES completion:nil];
}


- (IBAction)done:(id)sender {
	[self dismissViewControllerAnimated:YES completion:nil];
}



#pragma mark - Data retrieval methods


- (void) clearMessages
{
	[self.messages      removeAllObjects];
	[self.avatars       removeAllObjects];
    [self.chatMessages  removeAllObjects];
	[self.collectionView reloadData];
}


- (void) createMentionSuggestions
{
	NSMutableArray *suggestions = [[NSMutableArray alloc] init];
	if ( self.chatRecord.participants_eligible )
	{
		NSArray	*keys = [self.chatRecord.participants_eligible allKeys];
		for ( NSString *key in keys )
		{
			[suggestions addObject:[[self.chatRecord.participants_eligible objectForKey:key] objectForKey:@"alias"]];
		}
	}
	[suggestions addObject:@"@all"];
	self.mentionSuggestions = [suggestions sortedArrayUsingSelector:@selector(localizedCaseInsensitiveCompare:)];
}


/**
 *	Add a mention string to the input toolbar
 *
 *	@param	NSString*	mention		the name to add @ to to create the mention
 */
- (void) addMentionToInput:(NSString *)nameToMention
{
	if ( nameToMention==nil || [nameToMention length]==0 )
		return;

	NSString *mention = [[BoomtownChat sharedInstance] getInfoType:@"alias" forResource:nameToMention];
	if ( mention == nil )
	{
//		mention = nameToMention;
		// If we can't find an alias then we're done - it could be a bot
		return;
	}
	else
	{
		NSArray *tokens = [nameToMention componentsSeparatedByString:@";"];
		NSString *rc = tokens[0];
		if ( [rc isEqualToString:mention] )
			return;
	}

	NSString *text = self.inputToolbar.contentView.textView.text;
	if ( [text length] == 0 )
	{
		text = mention;
	}
	else if ( [text hasSuffix:@" "] )
	{
		text = [NSString stringWithFormat:@"%@%@ ", text, mention];
	}
	else
	{
		text = [NSString stringWithFormat:@"%@ %@ ", text, mention];
	}
	self.inputToolbar.contentView.textView.text = text;
	self.sendButton.enabled = YES;
}


- (JSQMessagesAvatarImage *)getAvatarForResource:(NSString *)resource
{
	if ( APP_DELEGATE.avatars && [APP_DELEGATE.avatars objectForKey:resource] )
	{
		return (JSQMessagesAvatarImage *)[APP_DELEGATE.avatars objectForKey:resource];
	}
	else
	{
		JSQMessagesAvatarImage *avatar;
		NSArray *tokens = [resource componentsSeparatedByString:@";"];
		tokens = [tokens[0] componentsSeparatedByString:@":"];
		if ( [tokens count] == 2 )
		{
			NSString *url = [NSString stringWithFormat:@"%@/api/v1/avatar/%@/%@/50,50", BoomtownMembersAPIBaseURL,
							 tokens[0],
							 tokens[1]];
			UIImage *image = [self imageForUrl:url];
			if ( image != nil )
			{
				avatar = [JSQMessagesAvatarImageFactory avatarImageWithImage:image
																diameter:kJSQMessagesCollectionViewAvatarSizeDefault];
				[APP_DELEGATE.avatars setObject:avatar forKey:resource];
				return avatar;
			}
		}
	}
	return nil;
}


- (JSQMessagesAvatarImage *)getAvatarForUrl:(NSString *)url
{
	JSQMessagesAvatarImage *avatar;
	UIImage *image = [self imageForUrl:url];
	if ( image != nil )
	{
		avatar = [JSQMessagesAvatarImageFactory avatarImageWithImage:image
															diameter:kJSQMessagesCollectionViewAvatarSizeDefault];
		return avatar;
	}
	return nil;
}


- (UIImage *) imageForUrl:(NSString *)url
{
	NSData * data = [[NSData alloc] initWithContentsOfURL: [NSURL URLWithString:url]];
	UIImage *image = [[UIImage alloc] initWithData:data];
	return image;
}


#pragma mark - JSQMessagesViewController method overrides

- (void)didPressSendButton:(UIButton *)button
		   withMessageText:(NSString *)text
				  senderId:(NSString *)senderId
		 senderDisplayName:(NSString *)senderDisplayName
					  date:(NSDate *)date
{
	[SVProgressHUD show];

	[[BoomtownChat sharedInstance] sendGroupchatMessage:text sendOnly:NO];

	[JSQSystemSoundPlayer jsq_playMessageSentSound];

	[self finishSendingMessageAnimated:YES];

	[SVProgressHUD dismiss];

	[self.inputToolbar.contentView.textView resignFirstResponder];
}


- (void)didPressAccessoryButton:(UIButton *)sender
{
    if ( self.inRoom ) {
        //  Hide the keyboard
        [self.view endEditing:YES];

        UINavigationController	*navigationController = [[UINavigationController alloc] initWithRootViewController:APP_DELEGATE.photoViewController];
        APP_DELEGATE.photoViewController.delegate = self;
        APP_DELEGATE.photoViewController.singleSelection = NO;
        APP_DELEGATE.photoViewController.saveImageAction = ^(NSArray *items){
            self.sendButton.enabled = NO;
            for ( id item in items ) {
                if ( [item isKindOfClass:[UIImage class]]) {
                    [[BoomtownAPI sharedInstance] apiMembersCommPutFile:self.chatRecord.comm_id image:[item scaleAndRotateImage] message:nil];

                } else if ( [item isKindOfClass:[PHAsset class]] ) {
                    [[PHImageManager defaultManager] requestImageDataForAsset:item
                                                                      options:nil
                                                                resultHandler:
                     ^(NSData *imageData, NSString *dataUTI, UIImageOrientation orientation, NSDictionary *info){
                         UIImage *image = [UIImage imageWithData:imageData];
                         [[BoomtownAPI sharedInstance] apiMembersCommPutFile:self.chatRecord.comm_id image:[image scaleAndRotateImage] message:nil];
                     }];
                }
                self.sendButton.enabled = YES;

            }
        };
        [self presentViewController:navigationController animated:YES completion:^{
        }];
    } else {
        [self warn:NSLocalizedString(@"You have not yet joined the chat room.", nil)];
    }
}


//- (void)actionSheet:(UIActionSheet *)actionSheet didDismissWithButtonIndex:(NSInteger)buttonIndex
//{
//	if (buttonIndex == actionSheet.cancelButtonIndex) {
//		return;
//	}
//
//	switch (buttonIndex) {
//		case 0:
////			[self addPhotoMediaMessage];
//            [self takePhoto:nil];
//			break;
//
//		case 1:
//		{
//            [self selectFromLibrary:nil];
////			__weak UICollectionView *weakView = self.collectionView;
////
////			[self addLocationMediaMessageCompletion:^{
////				[weakView reloadData];
////			}];
//		}
//			break;
//
////		case 2:
////			[self addVideoMediaMessage];
////			break;
//        default:
//            break;
//	}
//
//	[JSQSystemSoundPlayer jsq_playMessageSentSound];
//
//	[self finishSendingMessageAnimated:YES];
//}
//
//
//#pragma mark - Photo handling
//
//- (IBAction)takePhoto:(UIButton *)sender {
//    APP_DELEGATE.activityFeedViewController.gettingPhoto = YES;
//    UINavigationController	*navigationController = [[UINavigationController alloc] initWithRootViewController:APP_DELEGATE.photoViewController];
//    APP_DELEGATE.photoViewController.delegate = self;
//    [self presentViewController:navigationController animated:YES completion:^{
//        [APP_DELEGATE.photoViewController showImagePickerForCamera:nil];
//    }];
//}
//
//
//- (IBAction)selectFromLibrary:(UIButton *)sender {
//    APP_DELEGATE.activityFeedViewController.gettingPhoto = YES;
//    UINavigationController	*navigationController = [[UINavigationController alloc] initWithRootViewController:APP_DELEGATE.photoViewController];
//    APP_DELEGATE.photoViewController.delegate = self;
//    [self presentViewController:navigationController animated:YES completion:^{
//        [APP_DELEGATE.photoViewController showImagePickerForPhotoPicker:nil];
//    }];
//}


- (void) didSelectPhoto:(UIImage *)photo
{
//    JSQPhotoMediaItem *photoItem = [[JSQPhotoMediaItem alloc] initWithImage:photo];
//    BTMessage *photoMessage = [BTMessage messageWithSenderId:self.senderId
//                                                   displayName:self.senderDisplayName
//                                                         media:photoItem];
//    [self.messages addObject:photoMessage];
    self.sendButton.enabled = NO;

    [[BoomtownAPI sharedInstance] apiMembersCommPutFile:self.chatRecord.comm_id image:[photo scaleAndRotateImage] message:nil];
}



- (void)addPhotoMediaMessage
{
	JSQPhotoMediaItem *photoItem = [[JSQPhotoMediaItem alloc] initWithImage:[UIImage imageNamed:@"technician-splash-square-white@2x.png"]];
	BTMessage *photoMessage = [BTMessage messageWithSenderId:self.senderId
												   displayName:self.senderDisplayName
														 media:photoItem];
	[self.messages addObject:photoMessage];
}


- (void)addLocationMediaMessageCompletion:(JSQLocationMediaItemCompletionBlock)completion
{
	CLLocation *ferryBuildingInSF = [[CLLocation alloc] initWithLatitude:37.795313 longitude:-122.393757];

	JSQLocationMediaItem *locationItem = [[JSQLocationMediaItem alloc] init];
	[locationItem setLocation:ferryBuildingInSF withCompletionHandler:completion];

	BTMessage *locationMessage = [BTMessage messageWithSenderId:self.senderId
													  displayName:self.senderDisplayName
															media:locationItem];
	[self.messages addObject:locationMessage];
}


- (void)addVideoMediaMessage
{
	// don't have a real video, just pretending
	NSURL *videoURL = [NSURL URLWithString:@"file://"];

	JSQVideoMediaItem *videoItem = [[JSQVideoMediaItem alloc] initWithFileURL:videoURL isReadyToPlay:YES];
	BTMessage *videoMessage = [BTMessage messageWithSenderId:self.senderId
												   displayName:self.senderDisplayName
														 media:videoItem];
	[self.messages addObject:videoMessage];
}


#pragma mark - Chat connect

/**
 *	Establish a session with the XMPP server
 *
 *	@param	NSInteger	timeout		the connect timeout
 */
- (void) connectWithTimeout:(NSInteger)timeout
{
	if ( !self.jid || !self.password )
		return;

	self.connectTimer = [NSTimer scheduledTimerWithTimeInterval:timeout+1
														 target:self
													   selector:@selector(handleConnectTimeout)
													   userInfo:nil
														repeats:NO];
    dispatch_async(dispatch_get_main_queue(), ^{
        [SVProgressHUD showWithStatus:NSLocalizedString(@"Connecting to chat server",nil)];
    });
	[[BoomtownChat sharedInstance] connectToServerWithJid:self.jid password:self.password host:self.host port:self.port timeout:timeout];
}


- (void) joinRoom
{
    if ( self.inRoom ) {
        [self.joinRoomTimer invalidate];
        self.joinRoomTimer = nil;
        return;
    }

	if ( self.chatRecord != nil )
		self.muc = self.chatRecord.external_id;
	else
		self.muc = [BoomtownAPI sharedInstance].current_member.xmpp_comm_id;

    dispatch_async(dispatch_get_main_queue(), ^{
        [SVProgressHUD showWithStatus:NSLocalizedString(@"Joining chat room",nil)];
    });
	[APP_DELEGATE enterChat:self.chatRecord.comm_id];

	self.joinRoomTimer = [NSTimer scheduledTimerWithTimeInterval:[Settings sharedInstance].timeoutChatConnect
														  target:self
														selector:@selector(handleJoinRoomTimeout)
														userInfo:nil
														 repeats:NO];
	[[BoomtownChat sharedInstance] joinRoom:self.muc nickname:self.nickname];
}


#pragma mark - Chat delegates

/**
 *	Handle connected chat
 */
- (void) chat:(id)chat didConnect:(NSInteger)status error:(NSError *)error;
{
	[self.connectTimer invalidate];
	self.connectTimer = nil;
	[SVProgressHUD dismiss];

	[self joinRoom];
}


- (void) chat:(id)chat didTimeoutConnect:(NSInteger)status error:(NSError *)error;
{
	[self handleConnectTimeout];
}


- (void) chat:(id)chat didDisconnect:(NSInteger)status 	error:(NSError *)error;
{
    NSLog(@"ChatViewController didDisconnect");
    self.inRoom = NO;

    if ( APP_DELEGATE.currentCommId != nil ) {
        [SVProgressHUD showWithStatus:NSLocalizedString(@"Disconnected. Reconnecting...",nil)];
        if ( ![[BoomtownChat sharedInstance] isConnected] ) {
            [self connectWithTimeout:[Settings sharedInstance].timeoutChatConnect];
        }
    }
}


- (void) chat:(id)chat didNotAuthenticate:(NSXMLElement *)error
{
	[self warn:NSLocalizedString(@"Unable to log in the chat.", nil)];
}


- (void)chat:(id)chat didJoinRoom:(XMPPRoom *)sender error:(NSError *)error
{
    dispatch_async(dispatch_get_main_queue(), ^{
        [self.joinRoomTimer invalidate];
        self.joinRoomTimer = nil;

        [SVProgressHUD dismiss];
    });
	self.title = (self.chatRecord.title!=nil) ? self.chatRecord.title : NSLocalizedString(@"Connect", nil);
	self.inRoom = YES;
//	[self clearMessages];
}

- (void)chat:(id)chat didLeaveRoom:(XMPPRoom *)sender error:(NSError *)error
{
    self.inRoom = NO;
    if ( [BoomtownChat sharedInstance].isConnected )
        [self joinRoom];
}


- (void)chat:(id)chat didPerformAction:(NSString *)action
{
    NSLog(@"action: %@", action);
}


- (void) chat:(id)chat didReceiveMessage:(BTMessage *)message
{
    for ( ChatActionButton *button in message.chatActionButtons ) {
        NSString __weak *weakAction = button.action;
        button.handleButtonAction = ^(NSString *label, NSString *action) {
            [self handleButtonAction:weakAction label:label message:message];
        };
    }
    [self.messages addObject:message];
	[self finishReceivingMessage];
}


- (void) handleButtonAction:(NSString *)weakAction label:(NSString *)label message:(BTMessage *)message
{
    NSURLComponents *url = [NSURLComponents componentsWithString:weakAction];
    if ( [url.scheme isEqualToString:@"bt-action"] ) {
        NSString *query = [url.query stringByReplacingOccurrencesOfString:@"&amp;" withString:@"&"];
        NSArray *queryParams = [query componentsSeparatedByString:@"&"];
        NSMutableDictionary *queryDict = [NSMutableDictionary new];
        for ( NSString *param in queryParams ) {
            NSArray *tokens = [param componentsSeparatedByString:@"="];
            queryDict[tokens[0]] = tokens[1];
        }
        [BoomtownAPI.sharedInstance apiMembersCommChatButtonCallback:APP_DELEGATE.currentCommId
                                                                from:message.senderId
                                                              action:url.host
                                                              params:queryDict
                                                             success:^(AFHTTPRequestOperation *operation, id responseObject)
         {
             id successJSON = responseObject[@"success"];
             if ( successJSON && [successJSON isKindOfClass:[NSNumber class]] ) {
                 if ( [successJSON boolValue] ) {
                     NSString *message = [NSString stringWithFormat:@"%@ succeeded.", label];
                     [APP_DELEGATE warnWithTitle:nil message:message];
                 } else {
                     NSString *message = [NSString stringWithFormat:@"%@ failed.", label];
                     [APP_DELEGATE warnWithTitle:nil message:message];
                 }
             }
         }
                                                             failure:^(AFHTTPRequestOperation *operation, NSError *error)
         {
             NSString *message = [NSString stringWithFormat:@"%@ failed.", label];
             [APP_DELEGATE warnWithTitle:nil message:message];
         }];
    }
    else if ( [url.scheme isEqualToString:@"http"] ) {
        WebViewController *webViewController = [WebViewController controllerWithAddress:weakAction
                                                                                  title:NSLocalizedString(@"Attachment", nil)
                                                                        backButtonTitle:NSLocalizedString(@"Cancel", nil)];
        APP_DELEGATE.webViewController = webViewController;
        UINavigationController *navigationController = [[UINavigationController alloc] initWithRootViewController:webViewController];
        dispatch_async(dispatch_get_main_queue(), ^{
            [self presentViewController:navigationController animated:YES completion:nil];
        });
    }
    else if ( [url.scheme isEqualToString:@"bt-msg"] ) {
        NSString *msg = [weakAction substringFromIndex:9];
        [[BoomtownChat sharedInstance] sendGroupchatMessage:msg sendOnly:NO];
    }
    else if ( [url.scheme isEqualToString:@"bt-bot"] || [url.scheme isEqualToString:@"bt-data"] ) {
        NSString *json = [BoomtownChatMessage createJSONMessage:weakAction sender:self.senderId];
        if ( json ) {
            [[BoomtownChat sharedInstance] sendGroupchatMessage:json sendOnly:NO];
        }
    }
    else if ( [url.scheme isEqualToString:@"bt-relay"] ) {
        // ignore, for Relay chat button clicks
    }
    else if ( [url.scheme isEqualToString:@"bt-connect"] ) {
        // handle Connect-specific URIs, for example, navigate to issue with ID=x
    }
}

- (void) addChatMessage:(BoomtownChatMessage *)message
{
	[self postprocessMessage:message];

    if ( message.preview!=nil && message.preview.length>0 ) {
        UIImage *previewImage = [UIImage imageWithURL:[NSURL URLWithString:message.preview]];
        JSQPhotoMediaItem *photoItem = [[JSQPhotoMediaItem alloc] initWithImage:previewImage];
        BTMessage *photoMessage = [BTMessage messageWithSenderId:message.from
                                                       displayName:message.fromName
                                                             media:photoItem];
        [self.messages addObject:photoMessage];
    }

    if ( message.text!=nil && message.text.length>0 ) {
        BTMessage *btMessage = [[BTMessage alloc] initWithSenderId:message.from
                                                    senderDisplayName:message.fromName
                                                                 date:message.date
                                                                 text:message.text];
        [self.messages addObject:btMessage];
    }
}


- (void) removeChatMessageAtIndex:(long)index
{
    [self.chatMessages  removeObjectAtIndex:index];
}


/*
 Sample json payloads

 {"timestamp":"2016-02-16T14:29:25.629-08:00","message":"Chuck Norris doesn't needs try-catch, exceptions are too afraid to raise.","secret":"ac7938d40cfc2307e2bf325d28e7884e","context":{"object":"Chuck Says","object_id":"---","from_name":"Boom Bot","from_avatar":"https://boom-0-api.dev.gizmocreative.com/api/v1/avatar/beat/bot/128,128"}}

 {"timestamp":"2016-02-16T14:35:19.032-08:00","message":"Wo hu cang long. The translation from Mandarin Chinese reads: &quot;Crouching Chuck, Hidden Norris&quot;","secret":"ac7938d40cfc2307e2bf325d28e7884e","context":{"object":"Chuck Says","object_id":"---","from_name":"Boom Bot","from_avatar":"https://boom-0-api.dev.gizmocreative.com/api/v1/avatar/beat/bot/128,128"}}

 */

- (void) postprocessMessage:(BoomtownChatMessage *)message
{
}


- (NSString *) stringFromDict:(NSDictionary *)dict key:(NSString *)key
{
	if ([[dict objectForKey:key] isKindOfClass:[NSString class]] )
		return [dict objectForKey:key];
	else
		return nil;
}


- (void) buddyOnline:(NSString *)user
{
	if ( ![self.buddies containsObject:user] )
	{
		[self.buddies addObject:user];
	}
}


- (void) buddyOffline:(NSString *)user
{
	if ( [self.buddies containsObject:user] )
	{
		[self.buddies removeObject:user];
	}

}


#pragma mark - UITextView delegate

- (void)textViewDidChange:(UITextView *)textView
{
    //  To get dictation to work I save the textview data because clicking "Done" on keyboard dictation seems to clear the text
    //  That way if it is cleared but had something in it earlier I can retrieve it (a bit of a hack but it works)
    NSString *curString;
    if ( textView.text.length==0 && _textViewText.length>0 ) {
        curString = _textViewText;
    } else {
        curString = textView.text;
        _textViewText = [NSString stringWithString:textView.text];
    }

	if ( curString.length == 0 )
	{
		self.autocompletionTableView.hidden = YES;
		[self.inputToolbar.contentView.textView resignFirstResponder];
		self.sendButton.enabled = NO;
		return;
	}
	if ( self.inRoom )
		self.sendButton.enabled = YES;
	CGRect frame = CGRectMake(textView.frame.origin.x, self.inputToolbar.frame.origin.y-kAutocompleteTableHeight, textView.frame.size.width, kAutocompleteTableHeight);

	self.autocompletionTableView.frame = frame;
	[self.autocompletionTableView textViewDidChange:textView];
}

#pragma mark - UITextField delegate

- (BOOL)textFieldShouldEndEditing:(UITextField *)textField {

	return YES;
}


- (BOOL)textFieldShouldReturn:(UITextField *)textField {

	[textField resignFirstResponder];

	return YES;
}


#pragma mark - Timer handlers

- (void) handleConnectTimeout
{
	[self.connectTimer invalidate];
	self.connectTimer = nil;
	[SVProgressHUD dismiss];

	if ( ![[BoomtownChat sharedInstance] isConnected] )
		[self warn:@"Unable to connect to the chat server."];
}


- (void) handleJoinRoomTimeout
{
    dispatch_async(dispatch_get_main_queue(), ^{
        [self.joinRoomTimer invalidate];
        self.joinRoomTimer = nil;
        [SVProgressHUD dismiss];
        if ( !self.inRoom )
            [self warn:@"Unable to join chat room."];
    });
}


- (void) warn:(NSString *)message
{
	dispatch_async(dispatch_get_main_queue(), ^{
		UIAlertController* alert = [UIAlertController alertControllerWithTitle:NSLocalizedString(@"Connect!", nil)
																	   message:message
																preferredStyle:UIAlertControllerStyleAlert];

		UIAlertAction* defaultAction = [UIAlertAction actionWithTitle:NSLocalizedString(@"OK", nil)
																style:UIAlertActionStyleDefault
															  handler:^(UIAlertAction * action) {
//																  [self dismissViewControllerAnimated:YES completion:nil];
															  }];

		[alert addAction:defaultAction];
		[self presentViewController:alert animated:YES completion:^{
//			[self dismissViewControllerAnimated:YES completion:nil];
		}];
	});
}


#pragma mark - AutoCompleteTableViewDelegate

- (NSArray*) autoCompletion:(AutocompletionTableView*) completer suggestionsFor:(NSString*) string{
	// with the prodided string, build a new array with suggestions - from DB, from a service, etc.
	return [NSArray arrayWithObjects:@"hostel",@"caret",@"carrot",@"house",@"horse", nil];
}

- (void) autoCompletion:(AutocompletionTableView*)completer didSelectAutoCompleteSuggestionWithIndex:(NSInteger) index{
	// invoked when an available suggestion is selected
	self.sendButton.enabled = YES;
}

- (void) autoCompletion:(AutocompletionTableView*)completer didComplete:(long) index
{
	// invoked when an available suggestion is selected
	[self.inputToolbar.contentView.textView resignFirstResponder];
}



#pragma mark - JSQMessages CollectionView DataSource

- (id<JSQMessageData>)collectionView:(JSQMessagesCollectionView *)collectionView messageDataForItemAtIndexPath:(NSIndexPath *)indexPath
{
	return [self.messages objectAtIndex:indexPath.item];
}


- (void)collectionView:(JSQMessagesCollectionView *)collectionView didDeleteMessageAtIndexPath:(NSIndexPath *)indexPath
{
	[self removeChatMessageAtIndex:indexPath.item];
}


- (id<JSQMessageBubbleImageDataSource>)collectionView:(JSQMessagesCollectionView *)collectionView messageBubbleImageDataForItemAtIndexPath:(NSIndexPath *)indexPath
{
	/**
	 *  You may return nil here if you do not want bubbles.
	 *  In this case, you should set the background color of your collection view cell's textView.
	 *
	 *  Otherwise, return your previously created bubble image data objects.
	 */

	BTMessage *message = [self.messages objectAtIndex:indexPath.item];

	if ([message.senderId isEqualToString:self.senderId]) {
		return self.outgoingBubbleImageData;
	}

	return self.incomingBubbleImageData;
}


- (id<JSQMessageAvatarImageDataSource>)collectionView:(JSQMessagesCollectionView *)collectionView avatarImageDataForItemAtIndexPath:(NSIndexPath *)indexPath
{
	/**
	 *  Return `nil` here if you do not want avatars.
	 *  If you do return `nil`, be sure to do the following in `viewDidLoad`:
	 *
	 *  self.collectionView.collectionViewLayout.incomingAvatarViewSize = CGSizeZero;
	 *  self.collectionView.collectionViewLayout.outgoingAvatarViewSize = CGSizeZero;
	 *
	 *  It is possible to have only outgoing avatars or only incoming avatars, too.
	 */

	/**
	 *  Return your previously created avatar image data objects.
	 *
	 *  Note: these the avatars will be sized according to these values:
	 *
	 *  self.collectionView.collectionViewLayout.incomingAvatarViewSize
	 *  self.collectionView.collectionViewLayout.outgoingAvatarViewSize
	 *
	 *  Override the defaults in `viewDidLoad`
	 */
	BTMessage *message = [self.messages objectAtIndex:indexPath.item];
	NSString *avatar = message.avatar;

	if ( [avatar length] > 0 )
	{
		return [self getAvatarForUrl:avatar];
	}
	else if ([message.senderId isEqualToString:self.senderId]) {
//		if (![NSUserDefaults outgoingAvatarSetting]) {
		return [self getAvatarForResource:message.senderId]; //nil;
//		}
	}
	else {
//		if (![NSUserDefaults incomingAvatarSetting]) {
		return [self getAvatarForResource:message.senderId]; //self.jobsImage;
//		}
	}


//	return nil; //`self.jobsImage; // nil; //[self.avatars objectForKey:message.senderId];
	return [self getAvatarForResource:message.senderId];
}


- (NSAttributedString *)collectionView:(JSQMessagesCollectionView *)collectionView attributedTextForCellTopLabelAtIndexPath:(NSIndexPath *)indexPath
{
	/**
	 *  This logic should be consistent with what you return from `heightForCellTopLabelAtIndexPath:`
	 *  The other label text delegate methods should follow a similar pattern.
	 *
	 *  Show a timestamp for every 3rd message
	 */
	if (indexPath.item % 3 == 0) {
		BTMessage *message = [self.messages objectAtIndex:indexPath.item];
		return [[JSQMessagesTimestampFormatter sharedFormatter] attributedTimestampForDate:message.date];
	}

	return nil;
}


- (NSAttributedString *)collectionView:(JSQMessagesCollectionView *)collectionView attributedTextForMessageBubbleTopLabelAtIndexPath:(NSIndexPath *)indexPath
{
	BTMessage *message = [self.messages objectAtIndex:indexPath.item];

	/**
	 *  iOS7-style sender name labels
	 */
	if ([message.senderId isEqualToString:self.senderId]) {
		return nil;
	}

	if (indexPath.item - 1 > 0) {
		BTMessage *previousMessage = [self.messages objectAtIndex:indexPath.item - 1];
		if ([[previousMessage senderId] isEqualToString:message.senderId]) {
			return nil;
		}
	}

	/**
	 *  Don't specify attributes to use the defaults.
	 */
	return [[NSAttributedString alloc] initWithString:message.senderDisplayName];
}


- (NSAttributedString *)collectionView:(JSQMessagesCollectionView *)collectionView attributedTextForCellBottomLabelAtIndexPath:(NSIndexPath *)indexPath
{
	return nil;
}


#pragma mark - UICollectionView DataSource

- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section
{
	return [self.messages count];
}


- (UICollectionViewCell *)collectionView:(JSQMessagesCollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath
{
    /**
     *  Override point for customizing cells
     */
    //	JSQMessagesCollectionViewCell *cell = (JSQMessagesCollectionViewCell *)[super collectionView:collectionView cellForItemAtIndexPath:indexPath];
    BTMessagesCollectionViewCell *cell = (BTMessagesCollectionViewCell *)[super collectionView:collectionView cellForItemAtIndexPath:indexPath];

    /**
     *  Configure almost *anything* on the cell
     *
     *  Text colors, label text, label colors, etc.
     *
     *
     *  DO NOT set `cell.textView.font` !
     *  Instead, you need to set `self.collectionView.collectionViewLayout.messageBubbleFont` to the font you want in `viewDidLoad`
     *
     *
     *  DO NOT manipulate cell layout information!
     *  Instead, override the properties you want on `self.collectionView.collectionViewLayout` from `viewDidLoad`
     */

    BTMessage *msg = [self.messages objectAtIndex:indexPath.item];
    //    BoomtownChatMessage *msg = [self.messages objectAtIndex:indexPath.item];
    if (!msg.isMediaMessage) {

        UIColor *textColor;
        if ([msg.senderId isEqualToString:self.senderId]) {
            textColor = [UIColor whiteColor];
            cell.textView.textColor = [UIColor whiteColor];
        }
        else {
            if ( msg.callId!=nil && msg.callId.length>0 ) {
                textColor = UIColorFromRGB(kColorLink);
                cell.textView.textColor = UIColorFromRGB(kColorLink);
            } else {
                textColor = [UIColor blackColor];
                cell.textView.textColor = [UIColor blackColor];
            }

            cell.textView.linkTextAttributes = @{ NSForegroundColorAttributeName : cell.textView.textColor,
                                                  NSUnderlineStyleAttributeName : @(NSUnderlineStyleSingle | NSUnderlinePatternSolid) };

        }

        BOOL emoticons = YES;
        if ( emoticons ) {
            NSMutableAttributedString *attributedString = [self attributedStringFromChatMessage:msg.text];
            [attributedString addAttribute:NSFontAttributeName value:cell.textView.font range:NSMakeRange(0, [attributedString length])];
            [attributedString addAttribute:NSForegroundColorAttributeName value:textColor range:NSMakeRange(0, [attributedString length])];

            cell.textView.attributedText = attributedString;

//            if ( msg.buttonText && msg.buttonText.length>0 &&
//                msg.buttonAction && msg.buttonAction.length>0 ) {
//                CGFloat buttonHeight = 44;
//                CGFloat contentInset = 8;
//
//                CGRect cellContent = cell.contentView.frame;
//                CGRect textContent = cell.textView.frame;
//
//                CGRect frame = CGRectMake(cell.textView.frame.origin.x+contentInset,
//                                          cell.textView.frame.origin.y+cell.textView.frame.size.height,
//                                          cell.textView.frame.size.width-contentInset*2,
//                                          buttonHeight);
//            }
        }

    }

    return cell;
}


- (NSMutableAttributedString *)attributedStringFromChatMessage:(NSString *)message
{
    NSArray *words = [message componentsSeparatedByString:@" "];

    NSMutableArray *ranges = [NSMutableArray new];
    NSRange range;
    range.location = 0;
    range.length   = 0;
    int start = 0;
    for ( int n=0; n<message.length; n++ ) {
        if ( [[message substringWithRange:NSMakeRange(n,1)] isEqualToString:@" "] ) {
            range = NSMakeRange(start, n-start);
            [ranges addObject:[NSValue valueWithRange:range]];
            if ( n < message.length-1 ) {
                n++;
                start = n;
            }
        }
    }
    if ( ranges.count == 0 ) {
        range = NSMakeRange(start, message.length);
        [ranges addObject:[NSValue valueWithRange:range]];
    }

    NSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc] initWithString:message];

    for ( int n=0; n<words.count; n++ ) {
        NSString *word = words[n];

        NSString *imageName = APP_DELEGATE.emoticonsByName[word];
        if ( imageName != nil ) {
            UIImage *image;
            AnimatedTextAttachment *textAttachment = [[AnimatedTextAttachment alloc] init];
            if ( [imageName hasSuffix:@".gif"] ) {
                NSArray *tokens = [imageName componentsSeparatedByString:@"."];
                NSURL *url = [[NSBundle mainBundle] URLForResource:tokens[0] withExtension:@"gif"];
                image = [UIImage animatedImageWithAnimatedGIFData:[NSData dataWithContentsOfURL:url]];
                long count = image.images.count;
                image = image.images[count/2];
            } else {
                image = [UIImage imageNamed:imageName];
            }
            textAttachment.image = image;
            NSMutableAttributedString *attrStringWithImage = (NSMutableAttributedString *)[NSAttributedString attributedStringWithAttachment:textAttachment];

            if ( words.count == 1 ) {
                attributedString = attrStringWithImage;
            } else {
                NSValue *value = ranges[n];
                range = [value rangeValue];
                [attributedString replaceCharactersInRange:range withAttributedString:attrStringWithImage];
            }
        }
    }
    return attributedString;
}


#pragma mark - UICollectionView Delegate

#pragma mark - Custom menu items

- (BOOL)collectionView:(UICollectionView *)collectionView canPerformAction:(SEL)action forItemAtIndexPath:(NSIndexPath *)indexPath withSender:(id)sender
{
	if (action == @selector(customAction:)) {
		return YES;
	}

	return [super collectionView:collectionView canPerformAction:action forItemAtIndexPath:indexPath withSender:sender];
}


- (void)collectionView:(UICollectionView *)collectionView performAction:(SEL)action forItemAtIndexPath:(NSIndexPath *)indexPath withSender:(id)sender
{
	if (action == @selector(customAction:)) {
		[self customAction:sender];
		return;
	}

	[super collectionView:collectionView performAction:action forItemAtIndexPath:indexPath withSender:sender];
}


- (void)customAction:(id)sender
{
	NSLog(@"Custom action received! Sender: %@", sender);

    [APP_DELEGATE warnWithTitle:@"Custom Action" message:nil];
}


#pragma mark - JSQMessages collection view flow layout delegate

#pragma mark - Adjusting cell label heights

- (CGFloat)collectionView:(JSQMessagesCollectionView *)collectionView
				   layout:(JSQMessagesCollectionViewFlowLayout *)collectionViewLayout heightForCellTopLabelAtIndexPath:(NSIndexPath *)indexPath
{
	/**
	 *  Each label in a cell has a `height` delegate method that corresponds to its text dataSource method
	 */

	/**
	 *  This logic should be consistent with what you return from `attributedTextForCellTopLabelAtIndexPath:`
	 *  The other label height delegate methods should follow similarly
	 *
	 *  Show a timestamp for every 3rd message
	 */
	if (indexPath.item % 3 == 0) {
		return kJSQMessagesCollectionViewCellLabelHeightDefault;
	}

	return 0.0f;
}

- (CGFloat)collectionView:(JSQMessagesCollectionView *)collectionView
				   layout:(JSQMessagesCollectionViewFlowLayout *)collectionViewLayout heightForMessageBubbleTopLabelAtIndexPath:(NSIndexPath *)indexPath
{
	/**
	 *  iOS7-style sender name labels
	 */
	BTMessage *currentMessage = [self.messages objectAtIndex:indexPath.item];
	if ([[currentMessage senderId] isEqualToString:self.senderId]) {
		return 0.0f;
	}

	if (indexPath.item - 1 > 0) {
		BTMessage *previousMessage = [self.messages objectAtIndex:indexPath.item - 1];
		if ([[previousMessage senderId] isEqualToString:[currentMessage senderId]]) {
			return 0.0f;
		}
	}

	return kJSQMessagesCollectionViewCellLabelHeightDefault;
}

- (CGFloat)collectionView:(JSQMessagesCollectionView *)collectionView
				   layout:(JSQMessagesCollectionViewFlowLayout *)collectionViewLayout heightForCellBottomLabelAtIndexPath:(NSIndexPath *)indexPath
{
	return 0.0f;
}

#pragma mark - Responding to collection view tap events

- (void)collectionView:(JSQMessagesCollectionView *)collectionView
				header:(JSQMessagesLoadEarlierHeaderView *)headerView didTapLoadEarlierMessagesButton:(UIButton *)sender
{
	NSLog(@"Load earlier messages!");
}

- (void)collectionView:(JSQMessagesCollectionView *)collectionView didTapAvatarImageView:(UIImageView *)avatarImageView atIndexPath:(NSIndexPath *)indexPath
{
    [self addMentionForIndexPath:indexPath];
}

- (void)collectionView:(JSQMessagesCollectionView *)collectionView didTapMessageBubbleAtIndexPath:(NSIndexPath *)indexPath
{
    BTMessage *chatMessage = [self.messages objectAtIndex:indexPath.item];
    if ( chatMessage.callId!=nil && chatMessage.callId.length>0 ) {
        [SVProgressHUD showWithStatus:NSLocalizedString(@"Joining call",nil)];
        [[BoomtownAPI sharedInstance] apiMembersCommGet:kJoinCallMessageReceived commId:chatMessage.callId type:kTypeVideo];
    }
    else if ( chatMessage.url!=nil && chatMessage.url.length>0 ) {
        WebViewController *webViewController = [WebViewController controllerWithAddress:chatMessage.url
                                                                                  title:NSLocalizedString(@"Attachment", nil)
                                                                        backButtonTitle:NSLocalizedString(@"Cancel", nil)];
        webViewController.showProgress = false;
        APP_DELEGATE.webViewController = webViewController;
        APP_DELEGATE.activityFeedViewController.showingPhoto = YES;
        UINavigationController *navigationController = [[UINavigationController alloc] initWithRootViewController:webViewController];
        dispatch_async(dispatch_get_main_queue(), ^{
            [self presentViewController:navigationController animated:YES completion:nil];
        });
    }
    else {
        BTMessage *msg = [self.messages objectAtIndex:indexPath.item];
        [self addMentionToInput:msg.senderId];
    }
}

- (void)collectionView:(JSQMessagesCollectionView *)collectionView didTapCellAtIndexPath:(NSIndexPath *)indexPath touchLocation:(CGPoint)touchLocation
{
	NSLog(@"Tapped cell at %@!", NSStringFromCGPoint(touchLocation));
//	JSQMessagesCollectionViewCell *cell = (JSQMessagesCollectionViewCell *)[collectionView cellForItemAtIndexPath:indexPath];
//	JSQMessage *msg = [self.messages objectAtIndex:indexPath.item];
//	[self addMentionToInput:cell.messageBubbleTopLabel.text];
//	[self addMentionToInput:msg.senderId];
}


- (void) addMentionForIndexPath:(NSIndexPath *)indexPath
{
    BTMessage *msg = [self.messages objectAtIndex:indexPath.item];
    //	[self addMentionToInput:cell.messageBubbleTopLabel.text];
    [self addMentionToInput:msg.senderId];
}


#pragma mark - JSQMessagesComposerTextViewPasteDelegate methods


- (BOOL)composerTextView:(JSQMessagesComposerTextView *)textView shouldPasteWithSender:(id)sender
{
	if ([UIPasteboard generalPasteboard].image) {
		// If there's an image in the pasteboard, construct a media item with that image and `send` it.
		JSQPhotoMediaItem *item = [[JSQPhotoMediaItem alloc] initWithImage:[UIPasteboard generalPasteboard].image];
		BTMessage *message = [[BTMessage alloc] initWithSenderId:self.senderId
												 senderDisplayName:self.senderDisplayName
															  date:[NSDate date]
															 media:item];
		NSDictionary *messageDict = [[NSDictionary alloc] init];
		[messageDict setValue:message forKey:@"JSQMessage"];
		[self.messages addObject:messageDict];
		[self.avatars addObject:@""];
//        [self.chatMessages addObject:[[BoomtownChatMessage alloc] init]];
		[self finishSendingMessage];
		return NO;
	}
	return YES;
}


#pragma mark - Application State Handling

- (void) applicationStateChanged:(NSNotification* )notification
{
	id object = [notification object];

	NSString *action = [object isKindOfClass:[NSString class]] ? (NSString *) object : nil;

	if (!action) {

	}
	else if([action isEqualToString:kCommGetSucceeded]){
        [SVProgressHUD dismiss];
		if( notification.userInfo ){
            if ( [[notification.userInfo objectForKey:kApplicationResponseType] intValue] == kTypeVideo ) {
                [SVProgressHUD dismiss];
                return;
            }
			BoomtownComm *chat_record = [notification.userInfo objectForKey:kJoinChatMessageReceived];
			if ([chat_record isKindOfClass:[BoomtownComm class]])
			{
				self.chatRecord = chat_record;

				[BoomtownChat sharedInstance].participantsEligible = self.chatRecord.participants_eligible;
				[self createMentionSuggestions];
				self.autocompletionTableView.suggestionsDictionary = self.mentionSuggestions;

				self.senderId	       = self.resource;
				self.senderDisplayName = [[BoomtownChat sharedInstance] getInfoType:@"name" forResource:self.resource];
				if ( self.senderDisplayName == nil )
					self.senderDisplayName = self.senderId;

				if ( ![[BoomtownChat sharedInstance] isConnected] )
					[self connectWithTimeout:[Settings sharedInstance].timeoutChatConnect];
				else
					[self joinRoom];
			}
		}

	}
	else if([action isEqualToString:kCommGetFailed]){
        [SVProgressHUD dismiss];
		if( notification.userInfo ){
			NSString *error = [notification.userInfo objectForKey:kApplicationStateChangedMessage];
			NSString *message;
			if ( error==nil || error.length==0 )
				message = @"Unable to enter chat";
			else
				message = [NSString stringWithFormat:@"Unable to enter chat: %@", error];
			[self warn:message];
		}

	}
    else if ( [action isEqualToString:kCommPutFileSucceeded] ) {
        self.payload = (NSString *)[notification.userInfo objectForKey:kApplicationStateChangedMessage];
//        BoomtownChatMessage *chatMessage = [[BoomtownChat sharedInstance] processMessageFromString:self.payload];
        [[BoomtownChat sharedInstance] sendGroupchatMessage:self.payload sendOnly:YES];
        self.sendButton.enabled = YES;
    }
    else if ( [action isEqualToString:kCommPutFileFailed] ) {
        self.sendButton.enabled = YES;
        [self warn:NSLocalizedString(@"Unable to upload item.", nil)];
    }

}



@end
